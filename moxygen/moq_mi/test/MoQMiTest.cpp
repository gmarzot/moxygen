/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include "moxygen/moq_mi/MoQMi.h"

#include <folly/logging/xlog.h>
#include <folly/portability/GTest.h>

using namespace moxygen;

const auto kTestData = folly::IOBuf::copyBuffer("Data: Hello world");
const auto kTestMetadata = folly::IOBuf::copyBuffer("Metadata: Hello world");

TEST(MoQMi, EncodeVideoH264TestNoMetadata) {
  // Expected wire format:
  uint8_t expectedWire[67] = {
      0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0x02, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0x05, 0x00, 0x44, 0x61, 0x74, 0x61, 0x3a, 0x20, 0x48, 0x65, 0x6c, 0x6c,
      0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64};

  // Test VideoH264AVCCWCPData with metadata
  auto dataToEncode = std::make_unique<MoQMi::VideoH264AVCCWCPData>(
      0x3FFFFFFFFFFFFF00, // SeqId
      0x3FFFFFFFFFFFFF01, // Pts
      0x3FFFFFFFFFFFFF04, // Timescale
      0x3FFFFFFFFFFFFF03, // Duration
      0x3FFFFFFFFFFFFF05, // Wallclock
      kTestData->clone(), // Data
      nullptr,            // Metadata
      0x3FFFFFFFFFFFFF02  // Dts
  );
  // Total: 1+8+8+8+8+8+8+1+17 = 67 bytes

  XLOG(INFO) << "dataToEncode->data->length()="
             << dataToEncode->data->computeChainDataLength();

  auto mi = MoQMi::toObjectPayload(std::move(dataToEncode));

  EXPECT_NE(mi, nullptr);
  EXPECT_EQ(mi->computeChainDataLength(), 67);

  folly::IOBufEqualTo eq;
  EXPECT_TRUE(eq(mi, folly::IOBuf::copyBuffer(expectedWire, 67)));
}

TEST(MoQMi, EncodeVideoH264TestWithMetadata) {
  // Expected wire format:
  uint8_t expectedWire[88] = {
      0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x02, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x05, 0x15, 0x4d, 0x65, 0x74, 0x61, 0x64,
      0x61, 0x74, 0x61, 0x3a, 0x20, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20,
      0x77, 0x6f, 0x72, 0x6c, 0x64, 0x44, 0x61, 0x74, 0x61, 0x3a, 0x20,
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64};

  // Test VideoH264AVCCWCPData with metadata
  auto dataToEncode = std::make_unique<MoQMi::VideoH264AVCCWCPData>(
      0x3FFFFFFFFFFFFF00,     // SeqId
      0x3FFFFFFFFFFFFF01,     // Pts
      0x3FFFFFFFFFFFFF04,     // Timescale
      0x3FFFFFFFFFFFFF03,     // Duration
      0x3FFFFFFFFFFFFF05,     // Wallclock
      kTestData->clone(),     // Data
      kTestMetadata->clone(), // Metadata
      0x3FFFFFFFFFFFFF02      // Dts
  );
  // Total: 1+8+8+8+8+8+8+21+1+17 = 88 bytes

  XLOG(INFO) << "dataToEncode->metadata->length()="
             << dataToEncode->metadata->length();
  XLOG(INFO) << "dataToEncode->data->length()=" << dataToEncode->data->length();

  auto mi = MoQMi::toObjectPayload(std::move(dataToEncode));

  EXPECT_NE(mi, nullptr);
  EXPECT_EQ(mi->computeChainDataLength(), 88);

  folly::IOBufEqualTo eq;
  EXPECT_TRUE(eq(mi, folly::IOBuf::copyBuffer(expectedWire, 88)));
}

TEST(MoQMi, EncodeAudioAAC) {
  // Expected wire format:
  uint8_t expectedWire[74] = {
      0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x04, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x06,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0x05, 0x44, 0x61, 0x74, 0x61, 0x3a, 0x20, 0x48, 0x65, 0x6c,
      0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64};

  // Test VideoH264AVCCWCPData with metadata
  auto dataToEncode = std::make_unique<MoQMi::AudioAACMP4LCWCPData>(
      0x3FFFFFFFFFFFFF00, // SeqId
      0x3FFFFFFFFFFFFF01, // Pts
      0x3FFFFFFFFFFFFF04, // Timescale
      0x3FFFFFFFFFFFFF03, // Duration
      0x3FFFFFFFFFFFFF05, // Wallclock
      kTestData->clone(), // Data
      0x3FFFFFFFFFFFFF06, // SampleFreq
      0x3FFFFFFFFFFFFF07  // NumChannels
  );
  // Total: 1+8+8+8+8+8+8+8+17 = 74 bytes

  XLOG(INFO) << "dataToEncode->data->length()="
             << dataToEncode->data->computeChainDataLength();

  auto mi = MoQMi::toObjectPayload(std::move(dataToEncode));

  EXPECT_NE(mi, nullptr);
  EXPECT_EQ(mi->computeChainDataLength(), 74);

  folly::IOBufEqualTo eq;
  EXPECT_TRUE(eq(mi, folly::IOBuf::copyBuffer(expectedWire, 74)));
}
